buildscript {

    ext {
        asciidoctorVersion = "1.5.9.2"
    }

    repositories {
        mavenLocal()
        maven { url "https://plugins.gradle.org/m2/" }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"
        classpath "io.spring.gradle:dependency-management-plugin:$springDependencyVersion"
        classpath "org.asciidoctor:asciidoctor-gradle-plugin:$asciidoctorVersion"
        classpath "io.github.swagger2markup:swagger2markup-gradle-plugin:$swagger2markupVersion"
        classpath "io.github.swagger2markup:swagger2markup:$swagger2markupVersion"
        classpath "io.github.swagger2markup:swagger2markup-import-files-ext:1.3.1"
        classpath "com.bluepapa32:gradle-watch-plugin:0.1.5"
        classpath "org.kordamp.gradle:livereload-gradle-plugin:0.2.1"

        classpath "org.asciidoctor:asciidoctor-gradle-jvm:3.0.0-alpha.3"

    }
}

subprojects {
    group "$group"
    version "$version"

    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    repositories {
        mavenLocal()
        maven { url 'http://repo.spring.io/plugins-release/' }
        mavenCentral()
    }

    dependencies {
        implementation libraries.swagger2
        implementation libraries.snakeyaml

    }

    if (project.name.startsWith('spring-boot')) {
        apply plugin: "org.springframework.boot"
        apply plugin: "io.spring.dependency-management"

        dependencies {
            testImplementation libraries.springRestdocs
        }
    }

}

configure(subprojects.findAll { it.name.endsWith('swagger') }) {

    apply plugin: 'pers.lysk.build.distribution'

    apply plugin: 'org.asciidoctor.convert'
    apply plugin: 'io.github.swagger2markup'


    ext {
        swaggerOutputDir = file("${buildDir}/swagger")
        asciiDocOutputDir = file("${buildDir}/asciidoc/generated")
        snippetsOutputDir = file("${buildDir}/asciidoc/snippets")
    }


    repositories {
        mavenLocal()
        maven { url 'http://repo.spring.io/plugins-release/' }
        mavenCentral()
    }

    dependencies {
        asciidoctor libraries.springRestdocs
        asciidoctor libraries.asciidoctorjPdf
    }


    test {
        systemProperty 'io.springfox.staticdocs.outputDir', swaggerOutputDir
        systemProperty 'io.springfox.staticdocs.snippetsOutputDir', snippetsOutputDir
    }

    convertSwagger2markup {
        dependsOn test

        swaggerInput "${swaggerOutputDir}/swagger.json"
        outputDir asciiDocOutputDir
        config = ['swagger2markup.markupLanguage': 'ASCIIDOC',
                  'swagger2markup.pathsGroupedBy': 'TAGS']
    }

    asciidoctorj {
        version = '1.5.5'
    }

    asciidoctor {
        dependsOn convertSwagger2markup
        sourceDir(file("${projectDir}/docs/asciidoc/"))
        sources {
            include 'index.adoc'
        }
        backends = ['html5', 'pdf']
        attributes = [
                doctype    : 'book',
                toc        : 'left',
                toclevels  : '3',
                numbered   : '',
                sectlinks  : '',
                sectanchors: '',
                hardbreaks : '',
                generated  : asciiDocOutputDir
        ]
    }


    bootJar {
        archiveFileName = project.name + ".jar"
        archiveClassifier.set('boot')
        excludes = ["*.jar"]
        includes = ["**/*.class", "MANIFEST.MF"]

        manifest {
            attributes "Manifest-Version": 1.0,
                    'Class-Path': 'config/'
        }
    }

//    task distribution(type: Zip) {
//        boolean includeArchiveDirectory = (project.hasProperty('includeArchive') ? Boolean.valueOf(project.findProperty('includeArchive').toString()) : false)
//        archiveFileName = "${project.name}-${project.version}-release.zip"
//        destinationDirectory = file("${buildDir}/release")
//        println("The distribution package whether contains archive name with value: ${includeArchiveDirectory}")
//        if (includeArchiveDirectory) {
//            into("${project.name}") {
//                from("${buildDir}/libs")
//            }
//        } else {
//            from("${buildDir}/libs")
//        }
//    }

//    task copyRelease(type: Copy) {
//        destinationDir = file("${buildDir}/libs")
//
//        into('lib') {
//            from configurations.compileClasspath
//        }
//
//        into('config') {
//            from("${buildDir}/resources/main") {
//                include '**/**.*'
//            }
//
//        }
//
//        into('bin') {
//            from("scripts")
//        }
//
//        into("config/META-INF/resources/docs") {
//            from("${asciidoctor.outputDir}/html5")
//        }
//    }
//
//    distribution.dependsOn asciidoctor, build, copyRelease


    distribution {
//        archiveFileName = "${project.name}-${project.version}-release.zip"
//        destinationDir(file("${project.buildDir}/release"))

//        String path = destinationDirectory.get().asFile.absolutePath
//        println("${path}")
        archiveStoreDirectory = file("${buildDir}/store")
        into("config/META-INF/resources/docs") {
            from("${asciidoctor.outputDir}/html5")
        }
    }
//    distribution.dependsOn asciidoctor
}
