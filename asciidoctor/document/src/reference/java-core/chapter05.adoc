=== Question and Answer

____
Common basic interview questions about jvm
____

==== 说一下 JVM 的主要组成部分, 及其作用

* Program Counter Register:
每个线程都需有独立的程序计数器，不同线程之间的程序计数器互不影响，独立存储
* JVM Stack: 同计数器也为线程私有，生命周期也相同，栈描述的是 Java 方法执行的内存模型
* Native Method Stack:本地方法栈为虚拟机使用到的 native 方法服务
* Java Heap:堆存放的对象是线程共享的，所以多线程的时候也需要同步机制
* Method Area:存储已被虚拟机加载的类信息、常量、静态变量

==== 说一下 JVM 运行时数据区

* 线程私有的数据区
** 程序计数器
** 虚拟机栈
** 本地方法栈
* 所有线程共有的数据区
** Java 堆
** 方法区

image:https://raw.githubusercontent.com/lawyerance/resources/master/interview/images/java/jvm/jvm-run-data-area.png[image]

==== 说一下堆栈的区别

[arabic]
. 栈内存存储的是局部变量而堆内存存储的是实体；
. 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；
. 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。

==== 队列和栈是什么？有什么区别

==== 什么是双亲委派模型

image:https://raw.githubusercontent.com/lawyerance/resources/master/interview/images/java/jvm/classloader.png[image]
每次收到类加载请求时，先将请求委派给父类加载器完成（所有加载请求最终会委派到顶层的 Bootstrap ClassLoader 加载器中），如果父类加载器无法完成这个加载（该加载器的搜索范围中没有找到对应的类），子类尝试自己加载

____
*双亲委派的好处*

* 避免同一个类被多次加载；
* 每个加载器只能加载自己范围内的类；
____

==== 说一下类加载的执行过程

image:https://raw.githubusercontent.com/lawyerance/resources/master/interview/images/java/jvm/class-life-cycle.jpg[image]

==== 怎么判断对象是否可以被回收

==== Java 中都有哪些引用类型

==== 说一下 JVM 有哪些垃圾回收算法

[arabic]
. 引用计数算法
. 根搜索算法
. 标记/清除算法
. 复制算法
. 标记/整理算法
. 分代收集算法

==== 说一下 JVM 有哪些垃圾回收器

[arabic]
. Serial 收集器
. ParNew 收集器
. Parallel Scavenge（并行回收）收集器
. Serial Old 收集器
. Parallel Old 收集器
. CMS 收集器
. G1 收集器

==== 详细介绍一下 CMS 垃圾回收器

==== 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别

==== 简述分代垃圾回收器是怎么工作的

==== 说一下 JVM 调优的工具

* Jconsole : jdk 自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。
* JProfiler：商业软件，需要付费。功能强大。
* VisualVM：JDK 自带，功能强大，与 JProfiler 类似。推荐

==== 常用的 JVM 调优的参数都有哪些
