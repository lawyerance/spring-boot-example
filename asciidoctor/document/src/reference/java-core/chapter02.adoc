=== Knowledge Point

==== Set

常用的 Set 有 HashSet 和 TreeSet

===== HashSet

HashSet 无序不可重复，底层是 HashMap 实现，HashMap 中的 key 是不能重复的，从而产生了不能重复的集合

===== TreeSet

TreeSet 有序不可重复，底层是 TreeMap 实现

===== LinkedHashSet

具有 HashSet 的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历 Set 时，结果会按元素插入的次序显示。

==== List

常用的 List 有 ArrayList 和 LinkedList

===== ArrayList

ArrayList 实现于 List、RandomAccess 接口。

[source,java]
----
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{

}
----

可以插入空数据，也支持随机访问，相当于动态数据，其中最重要的两个属性分别是:elementData 数组，以及 size 大小，默认为 10。由于 ArrayList 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 transient 修饰，可以防止被自动序列化。

===== Vector

Vector 也是实现于 List 接口，底层数据结构和 ArrayList 类似,也是一个动态数组存放数据。不过是在 add()方法的时候使用 synchronize 进行同步写数据，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器，基本不用了。

[source,java]
----
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    /**
     * Appends the specified element to the end of this Vector.
     *
     * @param e element to be appended to this Vector
     * @return {@code true} (as specified by {@link Collection#add})
     * @since 1.2
     */
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
}
----

===== LinkedList

LinkedList 底层是基于双向链表实现的，也实现了 List 接口

插入、删除都是移动指针，效率高 O(1)；查找需要遍历，效率低 O(n)，不是线程安全的。实现了 Deque 接口，所以 LinkedList 不止有队列的接口，还有栈的接口，可以使用 LinkedList 作为队列和栈的实现

===== CopyOnWriteArrayList

* CopyOnWriteArrayList 是 List 的一种线程安全的实现；
* 其实现原理采用”CopyOnWrite”的思路（不可变元素），即所有写操作，包括：add，remove，set 等都会触发底层数组的拷贝，从而在写操作过程中，不会影响读操作；避免了使用 synchronized 等进行读写操作的线程同步；
* CopyOnWrite 对于写操作来说代价很大，故不适合于写操作很多的场景；当遍历操作远远多于写操作的时候，适合使用 CopyOnWriteArrayList；
* 迭代器以”快照”方式实现，在迭代器创建时，引用指向 List 当前状态的底层数组，所以在迭代器使用的整个生命周期中，其内部数据不会被改变；并且集合在遍历过程中进行修改，也不会抛出 ConcurrentModificationException；迭代器在遍历过程中，不会感知集合的 add，remove，set 等操作；
* 因为迭代器指向的是底层数组的”快照”，因此也不支持对迭代器本身的修改操作，包括 add，remove，set 等操作，如果使用这些操作，将会抛出 UnsupportedOperationException；
* 相关 Happens-Before 规则：一个线程将元素放入集合的操作 happens-before 于其它线程访问/删除该元素的操作；

==== Map

常见的 Map 有 HashMap 和 Hashtable

===== HashMap

===== Hashtable

===== ConcurrentHashMap

=== Question and Answer

____
Common basic interview questions about container, like Set and List, Map
____

==== Java 容器都有哪些？

Set, List, Map

==== Collection 和 Collections 有什么区别？

java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有 List 与 Set。

Collections 则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。

==== List、Set、Map 之间的区别是什么？

==== HashMap 和 Hashtable 有什么区别？

[width="100%",cols="^13%,54%,33%",options="header",]
|===
|对比项 |HashMap |Hashtable
|实现 |Map 接口的实现 |还继承了 Directory

|线程安全 |线程不安全 |线程安全

|null 值 |Key 和 Value 均允许为 null |Key 和 Value 均允许不能为 null

|迭代器原理 |Iterator 是 fail-fast 迭代器 |enumerator 迭代器不是
fail-fast 的

|效率 |高 |低

|contains 问题 |移除了 contains 方法，换成了 containsKey 和
containsValue |保留有 contains 方法

|初始默认大小 |16 |11

|hash 算法 |强制容量为 2 的幂，重新根据 hashcode 计算 hash 值
|古老的除留余数发，直接使用 hashcode
|===

==== 如何决定使用 HashMap 还是 TreeMap？

对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。然而，假如你需要对一个有序的 key 集合进行遍历，TreeMap 是更好的选择。基于你的 collection 的大小，也许向 HashMap 中添加元素会更快，将 map 换为 TreeMap 进行有序 key 的遍历。

==== 说一下 HashMap 的实现原理？

[arabic]
. HashMap 概述： HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
. HashMap 的数据结构： 在 java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap 也不例外。HashMap 实际上是一个``链表散列''的数据结构，即数组和链表的结合体。
. 当我们往 Hashmap 中 put 元素时,首先根据 key 的 hashcode 重新计算 hash 值,根绝 hash 值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。
. 需要注意 Jdk 1.8 中对 HashMap 的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的 O(n)到 O(logn)

==== 说一下 HashSet 的实现原理？

[arabic]
. HashSet 底层由 HashMap 实现
. HashSet 的值存放于 HashMap 的 key 上
. HashMap 的 value 统一为 PRESENT

==== ArrayList 和 LinkedList 的区别是什么？

最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

==== 如何实现数组和 List 之间的转换？

* List 转换成为数组：调用 ArrayList 的 toArray 方法。
* 数组转换成为 List：调用 Arrays 的 asList 方法。

==== ArrayList 和 Vector 的区别是什么？

[arabic]
. Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用 CopyOnWriteArrayList。
. ArrayList 比 Vector 快，它因为有同步，不会过载。
. ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读列表。

==== Array 和 ArrayList 有何区别？

[arabic]
. Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。
. Array 是指定大小后不可变的，而 ArrayList 大小是可变的。
. Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。

==== 在 Queue 中 poll()和 remove()有什么区别？

poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

==== 哪些集合类是线程安全的？

[arabic]
. vector：就比 arraylist 多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在 web 应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
. statck：堆栈类，先进后出。
. hashtable：就比 hashmap 多了个线程安全。
. enumeration：枚举，相当于迭代器。

==== 迭代器 Iterator 是什么？

迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为``轻量级''对象，因为创建它的代价小。

==== Iterator 怎么使用？有什么特点？

Java 中的 Iterator 功能比较简单，并且只能单向移动：

[arabic]
. 使用方法 iterator()要求容器返回一个 Iterator。第一次调用 Iterator 的 next()方法时，它返回序列的第一个元素。注意：iterator()方法是 java.lang.Iterable 接口,被 Collection 继承。
. 使用 next()获得序列中的下一个元素。
. 使用 hasNext()检查序列中是否还有元素。
. 使用 remove()将迭代器新返回的元素删除。

Iterator 是 Java 迭代器最简单的实现，为 List 设计的 ListIterator 具有更多的功能，它可以从两个方向遍历 List，也可以从 List 中插入和删除元素。

==== Iterator 和 ListIterator 有什么区别？

[arabic]
. Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。
. Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。
. ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

==== 怎么确保一个集合不能被修改？

使用 Collections 工具内的 UnmodifiableXXX 方法，如：Collections.UnmodifiableCollection

=== Advance

____
Continue to expand the topic
____

==== ArrayList 越界问题

==== 并发容器

==== hash 碰撞

==== CAS

==== AQS

link:AQS[详解]
