
=== TCP 和 UDP 区别

* TCP 面向连接；UDP 面向无连接
* TCP 保证数据正确性；UDP 可能丢包
* TCP 传输速度慢；UDP 速度快
* 每一条 TCP 连接只能是点到点的；UDP
支持一对一，一对多，多对一和多对多的交互通信
* TCP 对系统资源要求较多，UDP 对系统资源要求较少。

=== 三次握手

image:https://raw.githubusercontent.com/lawyerance/resources/master/interview/images/network/three-way_handshake.png[image]

* 第一次握手：主机 A 发送位码为 syn ＝ 1,随机产生 seq number=x
的数据包到服务器，客户端进入 SYN_SEND 状态，等待服务器的确认；主机 B 由
SYN=1 知道，A 要求建立联机；
* 第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number(主机
A 的 seq+1),syn=1,ack=1,随机产生 seq=y 的包,此时服务器进入 SYN_RECV
状态;
* 第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq
number+1,以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number(主机
B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1
则连接建立成功。客户端和服务器端都进入 ESTABLISHED 状 态，完成 TCP
三次握手

[source,text]
----
6种TCP位码标识：
    SYN(synchronous建立联机)
    ACK(acknowledgement 确认)
    PSH(push传送)
    FIN(finish结束)
    RST(reset重置)
    URG(urgent紧急)
----

说明：`+Sequence number(顺序号码) Acknowledge number(确认号码)+`

=== 四次挥手

image:https://raw.githubusercontent.com/lawyerance/resources/master/interview/images/network/four-times-wave.png[image]

* 第一次挥手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence
Number 和 Acknowledgment Number，向主机 2 发送一个 FIN
报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1
没有数据要发送给主机 2 了；
* 第二次挥手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK
报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入
FIN_WAIT_2 状态；主机 2 告诉主机
1，我也没有数据要发送了，可以进行关闭连接了；
* 第三次挥手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2
进入 CLOSE_WAIT 状态；
* 第四次挥手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK
报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK
报文段以后，就关闭连接；此时，主机 1 等待 2MSL
后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1
也可以关闭连接了

=== 问题

[source,text]
----
1.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

2.client发送完最后一个ack之后，进入time_wait状态，但是他怎么知道server有没有收到这个ack呢？莫非sever也要等待一段时间，如果收到了这个ack就close，如果没有收到就再发一个fin给client？这么说server最后也有一个time_wait哦？求解答！

因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动连接一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动

关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：1.旧的TCP连接已经不存在了，系统此时只能返回RST包2.新的TCP连接被建立起来了，延迟包可能干扰新的连接，这就是为什么time_wait需要等待2MSL时长的原因。

----
